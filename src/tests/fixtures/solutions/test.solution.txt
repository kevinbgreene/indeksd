export type Value = 1 | 2 | 3;
export type Value2 = '1' | true | 0.2;
export type Value3 = Value | false;
export type Value4 = 'some';
export type Value5 = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
export type Value6 = {
  firstName: string;
  lastName: string;
};
export type Value7 = [string, Value6];
export type Authors = {
  id: number;
  name: string;
  email: string;
};
export type Status = {
  id: string;
  displayName: string;
};
export type Post = {
  postId: string;
  name: string;
  content: string;
  author: number;
  status?: string;
};
export type PostWithJoins = {
  postId: string;
  name: string;
  content: string;
  author: Authors;
  status?: Status;
};
export type AuthorsIndexes = 'id' | 'name' | 'email';
export type StatusIndexes = 'id';
export type PostsIndexes =
  | 'postId'
  | 'name'
  | 'name_author'
  | 'author'
  | 'status';
export type AuthorsWhereQueryType<IndexName extends AuthorsIndexes> =
  IndexName extends 'id'
    ? number
    : IndexName extends 'name'
    ? string
    : IndexName extends 'email'
    ? string
    : never;
export type StatusWhereQueryType<IndexName extends StatusIndexes> =
  IndexName extends 'id' ? string : never;
export type PostsWhereQueryType<IndexName extends PostsIndexes> =
  IndexName extends 'postId'
    ? string
    : IndexName extends 'name'
    ? string
    : IndexName extends 'name_author'
    ? {
        name: string;
        author: number;
      }
    : IndexName extends 'author'
    ? number
    : IndexName extends 'status'
    ? string
    : never;
export type AuthorsAddArgs = {
  name: string;
  email: string;
};
export type StatusAddArgs = {
  id: string;
  displayName: string;
};
export type PostsAddArgs = {
  postId: string;
  name: string;
  content?: string;
  author: number | AuthorsPutArgs;
  status?: string | StatusPutArgs;
};
export type AuthorsPutArgs =
  | AuthorsAddArgs
  | {
      id: number;
      name: string;
      email: string;
    };
export type StatusPutArgs =
  | StatusAddArgs
  | {
      id: string;
      displayName: string;
    };
export type PostsPutArgs =
  | PostsAddArgs
  | {
      postId: string;
      name: string;
      content?: string;
      author: number | AuthorsPutArgs;
      status?: string | StatusPutArgs;
    };
export type AuthorsDeleteArgs =
  | number
  | {
      id: number;
    };
export type StatusDeleteArgs =
  | string
  | {
      id: string;
    };
export type PostsDeleteArgs =
  | string
  | {
      postId: string;
    };
export type AuthorsGetArgs =
  | number
  | {
      id: number;
    }
  | {
      name: string;
    }
  | {
      email: string;
    };
export type StatusGetArgs =
  | string
  | {
      id: string;
    };
export type PostsGetArgs =
  | string
  | {
      postId: string;
    }
  | {
      name: string;
    }
  | {
      name: string;
      author: number;
    }
  | {
      author: number;
    }
  | {
      status: string;
    };
const isAuthorsIdIndex = (
  arg?: AuthorsGetArgs,
): arg is {
  id: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isAuthorsNameIndex = (
  arg?: AuthorsGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isAuthorsEmailIndex = (
  arg?: AuthorsGetArgs,
): arg is {
  email: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'email')
  );
};
const isStatusIdIndex = (
  arg?: StatusGetArgs,
): arg is {
  id: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isPostsPostIdIndex = (
  arg?: PostsGetArgs,
): arg is {
  postId: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'postId')
  );
};
const isPostsNameIndex = (
  arg?: PostsGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isPostsNameAuthorIndex = (
  arg?: PostsGetArgs,
): arg is {
  name: string;
  author: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 2 &&
    Reflect.has(arg, 'name') &&
    Reflect.has(arg, 'author')
  );
};
const isPostsAuthorIndex = (
  arg?: PostsGetArgs,
): arg is {
  author: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'author')
  );
};
const isPostsStatusIndex = (
  arg?: PostsGetArgs,
): arg is {
  status: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'status')
  );
};
type RangeQuery<ArgType, ReturnType> = {
  isGreaterThan(arg: ArgType): ReturnType;
  isGreaterThanOrEqualTo(arg: ArgType): ReturnType;
  isLessThan(arg: ArgType): ReturnType;
  isLessThanOrEqualTo(arg: ArgType): ReturnType;
  isBetween(arg: { from: ArgType; to: ArgType }): ReturnType;
  isEqualTo(arg: ArgType): ReturnType;
};
export type SubscriptionEvent<ItemType, PrimaryKeyType> =
  | {
      type: 'add' | 'put';
      data: ItemType;
    }
  | {
      type: 'delete';
      data: PrimaryKeyType;
    };
export type AuthorsClient = {
  subscribe(
    eventName: 'change' | 'add' | 'put' | 'delete',
    callback: (event: SubscriptionEvent<Authors, number>) => void,
  ): void;
  add(
    arg: AuthorsAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  put(
    arg: AuthorsPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  delete(
    arg: AuthorsDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: AuthorsGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Authors>;
  where<IndexName extends AuthorsIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
    },
  ): RangeQuery<
    AuthorsWhereQueryType<IndexName>,
    Promise<ReadonlyArray<Authors>>
  >;
  sortBy(
    indexName: AuthorsIndexes,
    options?: {
      transaction?: IDBTransaction;
      count?: number;
    },
  ): Promise<ReadonlyArray<Authors>>;
};
export type StatusClient = {
  subscribe(
    eventName: 'change' | 'add' | 'put' | 'delete',
    callback: (event: SubscriptionEvent<Status, string>) => void,
  ): void;
  add(
    arg: StatusAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Status>;
  put(
    arg: StatusPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Status>;
  delete(
    arg: StatusDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: StatusGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Status>;
  where<IndexName extends StatusIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
    },
  ): RangeQuery<
    StatusWhereQueryType<IndexName>,
    Promise<ReadonlyArray<Status>>
  >;
  sortBy(
    indexName: StatusIndexes,
    options?: {
      transaction?: IDBTransaction;
      count?: number;
    },
  ): Promise<ReadonlyArray<Status>>;
};
export type PostsClient = {
  subscribe(
    eventName: 'change' | 'add' | 'put' | 'delete',
    callback: (event: SubscriptionEvent<Post, string>) => void,
  ): void;
  add(
    arg: PostsAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Post>;
  put(
    arg: PostsPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Post>;
  delete(
    arg: PostsDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): Promise<PostWithJoins>;
  get(
    arg: PostsGetArgs,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): Promise<Post>;
  get(
    arg: PostsGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): Promise<Post | PostWithJoins>;
  where<IndexName extends PostsIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): RangeQuery<
    PostsWhereQueryType<IndexName>,
    Promise<ReadonlyArray<PostWithJoins>>
  >;
  where<IndexName extends PostsIndexes>(
    indexName: IndexName,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): RangeQuery<PostsWhereQueryType<IndexName>, Promise<ReadonlyArray<Post>>>;
  where<IndexName extends PostsIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): RangeQuery<
    PostsWhereQueryType<IndexName>,
    Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>
  >;
  sortBy(
    indexName: PostsIndexes,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
      count?: number;
    },
  ): Promise<ReadonlyArray<PostWithJoins>>;
  sortBy(
    indexName: PostsIndexes,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
      count?: number;
    },
  ): Promise<ReadonlyArray<Post>>;
  sortBy(
    indexName: PostsIndexes,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
      count?: number;
    },
  ): Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>;
};
export type MyDatabaseClient = {
  transaction: (
    storeNames: Array<'Authors' | 'Status' | 'Posts'>,
    mode?: IDBTransactionMode,
  ) => IDBTransaction;
  authors: AuthorsClient;
  status: StatusClient;
  posts: PostsClient;
};
function createDatabaseClient(db: IDBDatabase): MyDatabaseClient {
  class Observable<ItemType, PrimaryKeyType> {
    #listeners: Map<
      string,
      Map<number, (event: SubscriptionEvent<ItemType, PrimaryKeyType>) => void>
    > = new Map();
    #nextId: number = 0;
    subscribe(
      eventName: 'change' | 'add' | 'put' | 'delete',
      callback: (event: SubscriptionEvent<ItemType, PrimaryKeyType>) => void,
    ): void {
      if (this.#listeners.has(eventName)) {
        this.#listeners.get(eventName)?.set?.(this.#nextId, callback);
      } else {
        const innerMap: Map<
          number,
          (event: SubscriptionEvent<ItemType, PrimaryKeyType>) => void
        > = new Map();
        innerMap.set(this.#nextId, callback);
        this.#listeners.set(eventName, innerMap);
      }
      this.#nextId += 1;
    }
    _push(eventName: 'delete', data: PrimaryKeyType): void;
    _push(eventName: 'add' | 'put', data: ItemType): void;
    _push(
      eventName: 'add' | 'put' | 'delete',
      data: ItemType | PrimaryKeyType,
    ): void {
      this.#listeners.get('change')?.forEach?.((callback) => {
        callback({ type: eventName, data } as SubscriptionEvent<
          ItemType,
          PrimaryKeyType
        >);
      });
      this.#listeners.get(eventName)?.forEach?.((callback) => {
        callback({ type: eventName, data } as SubscriptionEvent<
          ItemType,
          PrimaryKeyType
        >);
      });
    }
  }
  class AuthorsClientImpl extends Observable<Authors, number> {
    static tablesForTransaction: ReadonlyArray<string> = ['Authors'];
    add(
      arg: AuthorsAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const [] = await Promise.all([]);
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            const mergedResult: Authors = {
              ...arg,
              id: DBAddRequest.result,
            } as Authors;
            this._push('add', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: AuthorsPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const [] = await Promise.all([]);
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            const mergedResult: Authors = {
              ...arg,
              id: DBPutRequest.result,
            } as Authors;
            this._push('put', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: AuthorsDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readwrite');
        const store = tx.objectStore('Authors');
        const idToDelete: number = isAuthorsIdIndex(arg) ? arg.id : arg;
        const DBDeleteRequest: IDBRequest = store.delete(idToDelete);
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            this._push('delete', idToDelete);
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: AuthorsGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Authors> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readonly');
        const store = tx.objectStore('Authors');
        let DBGetRequest: IDBRequest | null = null;
        if (isAuthorsIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else if (isAuthorsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isAuthorsEmailIndex(arg)) {
          const index: IDBIndex = store.index('email');
          DBGetRequest = index.get([arg.email]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends AuthorsIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<
      AuthorsWhereQueryType<IndexName>,
      Promise<ReadonlyArray<Authors>>
    > {
      const tx =
        options?.transaction ?? db.transaction(['Authors'], 'readonly');
      const store = tx.objectStore('Authors');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<Authors>>(async (resolve, reject) => {
          const DBGetRequest: IDBRequest = target.getAll(range);
          if (DBGetRequest != null) {
            DBGetRequest.onerror = () => {
              if (DBGetRequest != null) {
                reject(DBGetRequest.error);
              } else {
                reject(
                  new Error(
                    'Unknown error occurred trying to perform operation',
                  ),
                );
              }
            };
            DBGetRequest.onsuccess = () => {
              if (DBGetRequest != null && DBGetRequest.result != null) {
                resolve((DBGetRequest as IDBRequest).result);
              } else {
                reject(new Error('No result found for query'));
              }
            };
          } else {
            reject(new Error('No available index for given query'));
          }
        });
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            case 'name': {
              return executeQuery(store.index('name'), IDBKeyRange.only(query));
            }
            case 'email': {
              return executeQuery(
                store.index('email'),
                IDBKeyRange.only(query),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: AuthorsIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<Authors>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Authors'], 'readonly');
        const store = tx.objectStore('Authors');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'id': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          case 'name': {
            const index: IDBIndex = store.index('name');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'email': {
            const index: IDBIndex = store.index('email');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          default: {
            throw new Error(
              'Trying to run query on unknown index: ' + indexName,
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const authorsClient = new AuthorsClientImpl();
  class StatusClientImpl extends Observable<Status, string> {
    static tablesForTransaction: ReadonlyArray<string> = ['Status'];
    add(
      arg: StatusAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Status> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readwrite');
        const store = tx.objectStore('Status');
        const [] = await Promise.all([]);
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            const mergedResult: Status = {
              ...arg,
              id: DBAddRequest.result,
            } as Status;
            this._push('add', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: StatusPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Status> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readwrite');
        const store = tx.objectStore('Status');
        const [] = await Promise.all([]);
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            const mergedResult: Status = {
              ...arg,
              id: DBPutRequest.result,
            } as Status;
            this._push('put', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: StatusDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readwrite');
        const store = tx.objectStore('Status');
        const idToDelete: string = isStatusIdIndex(arg) ? arg.id : arg;
        const DBDeleteRequest: IDBRequest = store.delete(idToDelete);
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            this._push('delete', idToDelete);
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: StatusGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Status> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readonly');
        const store = tx.objectStore('Status');
        let DBGetRequest: IDBRequest | null = null;
        if (isStatusIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends StatusIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<
      StatusWhereQueryType<IndexName>,
      Promise<ReadonlyArray<Status>>
    > {
      const tx = options?.transaction ?? db.transaction(['Status'], 'readonly');
      const store = tx.objectStore('Status');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<Status>>(async (resolve, reject) => {
          const DBGetRequest: IDBRequest = target.getAll(range);
          if (DBGetRequest != null) {
            DBGetRequest.onerror = () => {
              if (DBGetRequest != null) {
                reject(DBGetRequest.error);
              } else {
                reject(
                  new Error(
                    'Unknown error occurred trying to perform operation',
                  ),
                );
              }
            };
            DBGetRequest.onsuccess = () => {
              if (DBGetRequest != null && DBGetRequest.result != null) {
                resolve((DBGetRequest as IDBRequest).result);
              } else {
                reject(new Error('No result found for query'));
              }
            };
          } else {
            reject(new Error('No available index for given query'));
          }
        });
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: StatusIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<Status>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readonly');
        const store = tx.objectStore('Status');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'id': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          default: {
            throw new Error(
              'Trying to run query on unknown index: ' + indexName,
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const statusClient = new StatusClientImpl();
  class PostsClientImpl extends Observable<Post, string> {
    static tablesForTransaction: ReadonlyArray<string> = [
      'Posts',
      'Authors',
      'Status',
    ];
    add(
      arg: PostsAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Post> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...AuthorsClientImpl.tablesForTransaction,
                ...StatusClientImpl.tablesForTransaction,
                ...PostsClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Posts');
        const [authorsId, statusId] = await Promise.all([
          new Promise<number | null>(async (resolve, reject) => {
            if (arg.author == null) {
              resolve(null);
            } else if (typeof arg.author === 'number') {
              resolve(arg.author);
            } else {
              try {
                const author = await authorsClient.put(arg.author, {
                  transaction: tx,
                });
                resolve(author.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
          new Promise<string | null>(async (resolve, reject) => {
            if (arg.status == null) {
              resolve(null);
            } else if (typeof arg.status === 'string') {
              resolve(arg.status);
            } else {
              try {
                const status = await statusClient.put(arg.status, {
                  transaction: tx,
                });
                resolve(status.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
        ]);
        if (authorsId == null) {
          reject(
            new Error(
              'Unknown error occurred while trying to join table: Authors',
            ),
          );
          return;
        }
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
          content: arg.content != null ? arg.content : '',
          author: authorsId,
          status: statusId,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            const mergedResult: Post = {
              ...arg,
              author: authorsId,
              ...(statusId == null ? {} : { status: statusId }),
              postId: DBAddRequest.result,
            } as Post;
            this._push('add', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: PostsPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Post> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...AuthorsClientImpl.tablesForTransaction,
                ...StatusClientImpl.tablesForTransaction,
                ...PostsClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Posts');
        const [authorsId, statusId] = await Promise.all([
          new Promise<number | null>(async (resolve, reject) => {
            if (arg.author == null) {
              resolve(null);
            } else if (typeof arg.author === 'number') {
              resolve(arg.author);
            } else {
              try {
                const author = await authorsClient.put(arg.author, {
                  transaction: tx,
                });
                resolve(author.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
          new Promise<string | null>(async (resolve, reject) => {
            if (arg.status == null) {
              resolve(null);
            } else if (typeof arg.status === 'string') {
              resolve(arg.status);
            } else {
              try {
                const status = await statusClient.put(arg.status, {
                  transaction: tx,
                });
                resolve(status.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
        ]);
        if (authorsId == null) {
          reject(
            new Error(
              'Unknown error occurred while trying to join table: Authors',
            ),
          );
          return;
        }
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
          content: arg.content != null ? arg.content : '',
          author: authorsId,
          status: statusId,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            const mergedResult: Post = {
              ...arg,
              author: authorsId,
              ...(statusId == null ? {} : { status: statusId }),
              postId: DBPutRequest.result,
            } as Post;
            this._push('put', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: PostsDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...AuthorsClientImpl.tablesForTransaction,
                ...StatusClientImpl.tablesForTransaction,
                ...PostsClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Posts');
        const idToDelete: string = isPostsPostIdIndex(arg) ? arg.postId : arg;
        const DBDeleteRequest: IDBRequest = store.delete(idToDelete);
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            this._push('delete', idToDelete);
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): Promise<PostWithJoins>;
    get(
      arg: PostsGetArgs,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): Promise<Post>;
    get(
      arg: PostsGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): Promise<Post | PostWithJoins> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...AuthorsClientImpl.tablesForTransaction,
                    ...StatusClientImpl.tablesForTransaction,
                    ...PostsClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Posts'], 'readonly');
        const store = tx.objectStore('Posts');
        let DBGetRequest: IDBRequest | null = null;
        if (isPostsPostIdIndex(arg)) {
          DBGetRequest = store.get(arg.postId);
        } else if (isPostsNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isPostsNameAuthorIndex(arg)) {
          const index: IDBIndex = store.index('name_author');
          DBGetRequest = index.get([arg.name, arg.author]);
        } else if (isPostsAuthorIndex(arg)) {
          const index: IDBIndex = store.index('author');
          DBGetRequest = index.get([arg.author]);
        } else if (isPostsStatusIndex(arg)) {
          const index: IDBIndex = store.index('status');
          DBGetRequest = index.get([arg.status]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const post: Post = (DBGetRequest as IDBRequest).result;
              if (options?.withJoins != false) {
                Promise.all([
                  authorsClient.get(post.author, { transaction: tx }),
                  post.status == null
                    ? Promise.resolve<null>(null)
                    : statusClient.get(post.status, { transaction: tx }),
                ]).then(([author, status]) => {
                  resolve({
                    ...post,
                    author,
                    ...(status == null ? {} : { status }),
                  } as PostWithJoins);
                });
              } else {
                resolve(post);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends PostsIndexes>(
      indexName: IndexName,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): RangeQuery<
      PostsWhereQueryType<IndexName>,
      Promise<ReadonlyArray<PostWithJoins>>
    >;
    where<IndexName extends PostsIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<PostsWhereQueryType<IndexName>, Promise<ReadonlyArray<Post>>>;
    where<IndexName extends PostsIndexes>(
      indexName: IndexName,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): RangeQuery<
      PostsWhereQueryType<IndexName>,
      Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>
    > {
      const tx =
        options?.transaction ?? options?.withJoins != false
          ? db.transaction(
              Array.from(
                new Set([
                  ...AuthorsClientImpl.tablesForTransaction,
                  ...StatusClientImpl.tablesForTransaction,
                  ...PostsClientImpl.tablesForTransaction,
                ]),
              ),
              'readonly',
            )
          : db.transaction(['Posts'], 'readonly');
      const store = tx.objectStore('Posts');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>>(
          async (resolve, reject) => {
            const DBGetRequest: IDBRequest = target.getAll(range);
            if (DBGetRequest != null) {
              DBGetRequest.onerror = () => {
                if (DBGetRequest != null) {
                  reject(DBGetRequest.error);
                } else {
                  reject(
                    new Error(
                      'Unknown error occurred trying to perform operation',
                    ),
                  );
                }
              };
              DBGetRequest.onsuccess = () => {
                if (DBGetRequest != null && DBGetRequest.result != null) {
                  const post: ReadonlyArray<Post> = (DBGetRequest as IDBRequest)
                    .result;
                  if (options?.withJoins != false) {
                    Promise.all(
                      post.map((result) => {
                        return Promise.all([
                          authorsClient.get(result.author, { transaction: tx }),
                          result.status == null
                            ? Promise.resolve<null>(null)
                            : statusClient.get(result.status, {
                                transaction: tx,
                              }),
                        ]).then(([author, status]) => {
                          return {
                            ...result,
                            author,
                            ...(status == null ? {} : { status }),
                          } as PostWithJoins;
                        });
                      }),
                    ).then((result: ReadonlyArray<PostWithJoins>) => {
                      resolve(result);
                    });
                  } else {
                    resolve(post);
                  }
                } else {
                  reject(new Error('No result found for query'));
                }
              };
            } else {
              reject(new Error('No available index for given query'));
            }
          },
        );
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.lowerBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  true,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.lowerBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  false,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.upperBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  true,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.upperBound(
                  [
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  false,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.bound(
                  [
                    (
                      query.from as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query.from as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  [
                    (
                      query.to as {
                        name: string;
                        author: number;
                      }
                    ).name,
                    (
                      query.to as {
                        name: string;
                        author: number;
                      }
                    ).author,
                  ],
                  false,
                  false,
                ),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'postId': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            case 'name': {
              return executeQuery(store.index('name'), IDBKeyRange.only(query));
            }
            case 'name_author': {
              return executeQuery(
                store.index('name_author'),
                IDBKeyRange.only([
                  (
                    query as {
                      name: string;
                      author: number;
                    }
                  ).name,
                  (
                    query as {
                      name: string;
                      author: number;
                    }
                  ).author,
                ]),
              );
            }
            case 'author': {
              return executeQuery(
                store.index('author'),
                IDBKeyRange.only(query),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.only(query),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: PostsIndexes,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
        count?: number;
      },
    ): Promise<ReadonlyArray<PostWithJoins>>;
    sortBy(
      indexName: PostsIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<Post>>;
    sortBy(
      indexName: PostsIndexes,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
        count?: number;
      },
    ): Promise<ReadonlyArray<Post> | ReadonlyArray<PostWithJoins>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...AuthorsClientImpl.tablesForTransaction,
                    ...StatusClientImpl.tablesForTransaction,
                    ...PostsClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Posts'], 'readonly');
        const store = tx.objectStore('Posts');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'postId': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          case 'name': {
            const index: IDBIndex = store.index('name');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'name_author': {
            const index: IDBIndex = store.index('name_author');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'author': {
            const index: IDBIndex = store.index('author');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'status': {
            const index: IDBIndex = store.index('status');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          default: {
            throw new Error(
              'Trying to run query on unknown index: ' + indexName,
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const post: ReadonlyArray<Post> = (DBGetRequest as IDBRequest)
                .result;
              if (options?.withJoins != false) {
                Promise.all(
                  post.map((result) => {
                    return Promise.all([
                      authorsClient.get(result.author, { transaction: tx }),
                      result.status == null
                        ? Promise.resolve<null>(null)
                        : statusClient.get(result.status, { transaction: tx }),
                    ]).then(([author, status]) => {
                      return {
                        ...result,
                        author,
                        ...(status == null ? {} : { status }),
                      } as PostWithJoins;
                    });
                  }),
                ).then((result: ReadonlyArray<PostWithJoins>) => {
                  resolve(result);
                });
              } else {
                resolve(post);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const postsClient = new PostsClientImpl();
  return {
    transaction: (
      storeNames: Array<'Authors' | 'Status' | 'Posts'>,
      mode?: IDBTransactionMode,
    ): IDBTransaction => {
      return db.transaction(storeNames, mode);
    },
    authors: authorsClient,
    status: statusClient,
    posts: postsClient,
  };
}
export function init(): Promise<MyDatabaseClient> {
  return new Promise((resolve, reject) => {
    function createObjectStore(
      db: IDBDatabase,
      storeName: string,
      options: IDBObjectStoreParameters,
    ): IDBObjectStore {
      if (DBOpenRequest.transaction == null) {
        throw new Error(
          'Error opening database. Open request transaction is null.',
        );
      }
      if (db.objectStoreNames.contains(storeName)) {
        return DBOpenRequest.transaction.objectStore(storeName);
      } else {
        return db.createObjectStore(storeName, options);
      }
    }
    function createIndex(
      store: IDBObjectStore,
      indexName: string,
      keyPath: Array<string>,
      options: IDBIndexParameters,
    ): void {
      if (store.indexNames.contains(indexName)) {
        return;
      } else {
        store.createIndex(indexName, keyPath, options);
      }
    }
    function removeUnusedIndexes(
      store: IDBObjectStore,
      indexNames: ReadonlyArray<string>,
    ): void {
      for (const indexName of Array.from(store.indexNames)) {
        if (indexNames.includes(indexName) === false) {
          store.deleteIndex(indexName);
        }
      }
    }
    const DBOpenRequest = globalThis.indexedDB.open('MyDatabase', 3);
    DBOpenRequest.onerror = () => {
      reject(new Error('Error opening database: MyDatabase'));
    };
    DBOpenRequest.onsuccess = () => {
      const db = DBOpenRequest.result;
      resolve(createDatabaseClient(db));
    };
    DBOpenRequest.onupgradeneeded = () => {
      const db = DBOpenRequest.result;
      const AuthorsStore = createObjectStore(db, 'Authors', {
        keyPath: 'id',
        autoIncrement: true,
      });
      const StatusStore = createObjectStore(db, 'Status', { keyPath: 'id' });
      const PostsStore = createObjectStore(db, 'Posts', { keyPath: 'postId' });
      removeUnusedIndexes(AuthorsStore, ['name', 'email']);
      removeUnusedIndexes(StatusStore, []);
      removeUnusedIndexes(PostsStore, [
        'name',
        'name_author',
        'author',
        'status',
      ]);
      createIndex(AuthorsStore, 'name', ['name'], { unique: false });
      createIndex(AuthorsStore, 'email', ['email'], { unique: true });
      createIndex(PostsStore, 'name', ['name'], { unique: false });
      createIndex(PostsStore, 'name_author', ['name', 'author'], {
        unique: false,
      });
      createIndex(PostsStore, 'author', ['author'], { unique: false });
      createIndex(PostsStore, 'status', ['status'], { unique: false });
    };
  });
}
